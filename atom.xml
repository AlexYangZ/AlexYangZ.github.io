<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>STAY HUNGRY STAY FOOLISH</title>
  
  <subtitle>AthroughoutZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-28T02:34:19.946Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AlexYangZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome-and-vimium*shortcuts</title>
    <link href="http://yoursite.com/2020/03/28/Chrome-and-vimium-shortcuts/"/>
    <id>http://yoursite.com/2020/03/28/Chrome-and-vimium-shortcuts/</id>
    <published>2020-03-28T00:35:36.000Z</published>
    <updated>2020-03-28T02:34:19.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/AlexYangZ/image-store/raw/master/photos/vimium.png" alt="Oops.." title="Lucky"><br>Here is the Chrome shortcuts:<br><a href="https://blog.csdn.net/wangweiwells/article/details/88606142" target="_blank" rel="noopener">https://blog.csdn.net/wangweiwells/article/details/88606142</a><br>行内插入模式: [博客地址](<a href="https://blog.csdn.net/wangweiwells/article/details/88606142" target="_blank" rel="noopener">https://blog.csdn.net/wangweiwells/article/details/88606142</a> “CSDN”)<br>这个是<a href="https://blog.csdn.net/wangweiwells/article/details/88606142" title="Chrome的快捷键" target="_blank" rel="noopener">Chrome的快捷键</a>文章</p><p>Vimium shortcuts:you can get this photo via typing shift+/<br><img src="https://github.com/AlexYangZ/image-store/raw/master/photos/vimium.png" alt="Oops.." title="Lucky"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/AlexYangZ/image-store/raw/master/photos/vimium.png&quot; alt=&quot;Oops..&quot; title=&quot;Lucky&quot;&gt;&lt;br&gt;Here is the Chrome shortc
      
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2020/03/09/python/"/>
    <id>http://yoursite.com/2020/03/09/python/</id>
    <published>2020-03-09T12:58:21.000Z</published>
    <updated>2020-03-09T13:54:00.045Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Cpp</title>
    <link href="http://yoursite.com/2020/03/01/Algorithm-Cpp/"/>
    <id>http://yoursite.com/2020/03/01/Algorithm-Cpp/</id>
    <published>2020-02-29T16:57:49.000Z</published>
    <updated>2020-02-29T17:02:46.044Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="cpp" scheme="http://yoursite.com/categories/cpp/"/>
    
      <category term="Algorithm-cpp" scheme="http://yoursite.com/categories/cpp/Algorithm-cpp/"/>
    
    
      <category term="技术博客" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>学习Git-更好的利用Github</title>
    <link href="http://yoursite.com/2020/02/24/%E5%AD%A6%E4%B9%A0Git-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A9%E7%94%A8Github/"/>
    <id>http://yoursite.com/2020/02/24/%E5%AD%A6%E4%B9%A0Git-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A9%E7%94%A8Github/</id>
    <published>2020-02-23T16:01:50.000Z</published>
    <updated>2020-02-28T12:25:33.504Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上先进的<strong>分布式版本控制系统</strong>（没有之⼀）。 不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux 系统的源码已经由Git管理了！Git迅速成为流⾏行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><a id="more"></a><h4 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得新的版本，然后开始干 活，干完活了，再把自⼰ 的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p>集中式版本控制系统⼤大的⽑毛病就是必须联网才能工作，如果在局域网内还好，带宽够大， 速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的⽂文件就需要5分钟， 这还不得把⼈人给憋死啊。</p><p>分布式版本控制系统根本 没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这 样，你工作的时候，就 不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有⼀一个完整的版本 库，那多个人如何协作呢？比方说你在自己电脑上改 了文件A，你的同事也在他的电脑上改 了文件A，这时，你们俩之间只需把各⾃自的修改推送给对方，就可以互相看到对方的修改 了。<br>和集中式版本控制系统相比，分布式版本控制系统的安全性要⾼高很多，因为每个⼈人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把 SVN等远远抛在了后⾯面。CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统同时也是内容管理系统(CMS)和工作管理系统。Git对非线性开发强力支持,完全分布式.Git把内容按元数据方式存储而SVN是按文件存储,Git的内容完整性要优于SVN.Git的内容存储使用的是SHA-1哈希算法,其能确保代码内容的完整性确保在遇到磁盘故障和网络问题时可降低对版本库的破坏.</p><p>Git安装</p><p>Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装.MacOS可通过homebrew安装.Windows可直接官网下载安装程序然后默认安装选项即可.因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit      touch 文件;echo 内容&gt;文件 覆盖写;&gt;&gt;追加写;</span><br><span class="line">$ cd learngit         cat 文件 查看文件内容</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>把文件添加到版本库</p><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道。Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。</p><p>现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>把文件放到Git仓库需要两步:</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：  git rm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt    git add.会将修改及新文件提交暂存区不包括删除的文件.</span><br><span class="line">                       git add -u将修改的文件添加至暂存区,但不包括新文件.</span><br><span class="line">                       git add -A如上功能的集合</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><p>使用<code>git status</code>命令随时掌握工作区的状态</p><p>如果<code>git status</code>显示有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</p><p>版本回退</p><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><p>现在回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，版本号没必要写全，前几位就可以了，Git会自动去找。现在，你又可以乘坐时光机回到未来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p><img src="https://user-images.githubusercontent.com/11403346/75350471-8e822080-58e1-11ea-94a8-749651155375.png" alt="0"><br><img src="https://user-images.githubusercontent.com/11403346/75350820-18ca8480-58e2-11ea-8d4b-9344cff6d970.png" alt="1"></p><p>修改撤销</p><p><code>git checkout -- file</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令.</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。</p><p>远程仓库</p><p>创建SSH Key : $ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p><p>在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对.</p><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改.</p><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><p>分支管理</p><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/11403346/75350838-21bb5600-58e2-11ea-9854-450f9dd419ed.png" alt="2"></p><p>我们注意到切换分支使用<code>git checkout</code>，而前面讲过的撤销修改则是<code>git checkout --</code>，同一个命令，有两种作用,容易混淆。用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支,创建并切换到新的<code>dev</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch</code><name></name></p><p>切换分支：<code>git checkout</code>或者<code>git switch</code></p><p>创建+切换分支：<code>git checkout -b</code>或者<code>git switch -c</code></p><p>合并某分支到当前分支：<code>git merge</code></p><p>删除分支：<code>git branch -d</code></p><p><code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://user-images.githubusercontent.com/11403346/75350850-241db000-58e2-11ea-917c-71aecece1506.png" alt="3"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://user-images.githubusercontent.com/11403346/75350859-25e77380-58e2-11ea-8c59-6207a49ec067.png" alt="4"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><p>通常，合并分支时，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，创建并切换<code>dev</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>切换回<code>master</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://user-images.githubusercontent.com/11403346/75350864-2849cd80-58e2-11ea-8c0c-300206c71176.png" alt="6"></p><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。所以，团队合作的分支看起来就像这样：</p><p><img src="https://user-images.githubusercontent.com/11403346/75350879-30a20880-58e2-11ea-9c64-2708db7cfbda.png" alt="7"><br>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &apos;issue-101&apos;</span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &apos;dev&apos;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>再用<code>git status</code>看看状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p>不好看！</p><p>有没有解决方法？</p><p>有！</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p><ul><li><p>命令<code>git tag</code><tagname>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</tagname></p></li><li><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p></li><li><p>命令<code>git tag</code>可以查看所有标签。</p></li><li><p>命令<code>git push origin</code>可以推送一个本地标签；</p></li><li><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p></li><li><p>命令<code>git tag -d</code>可以删除一个本地标签；</p></li><li><p>命令`git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p></li><li><p>在GitHub上，可以任意Fork开源仓库；</p></li><li><p>自己拥有Fork后的仓库的读写权限；</p></li><li><p>可以推送pull request给官方仓库来贡献代码。</p></li></ul><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了.如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.classApp.class</span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p><p>第一步，安装<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into &apos;sample&apos;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h3 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h3><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h3 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h3><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>搭建Git服务器非常简单，通常10分钟即可完成；</li><li>要方便管理公钥，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitosis</a>；</li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>。</li></ul><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前世界上先进的&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;（没有之⼀）。 不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux 系统的源码已经由Git管理了！Git迅速成为流⾏行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>MAC-常用终端命令</title>
    <link href="http://yoursite.com/2020/02/22/MAC-%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/22/MAC-%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-22T14:40:26.000Z</published>
    <updated>2020-02-28T12:52:34.579Z</updated>
    
    <content type="html"><![CDATA[<p>无论是 Mac 还是 Linux 命令，通常从命令名称就可以看出其功能。但是常用终端命令很多，不可能熟练掌握所有命令。</p><a id="more"></a><p><strong>初识终端</strong></p><p>格式：“电脑用户名:当前路径 账户名$ 一条命令 ”</p><p>命令的构成：Command Name、Options、Arguments、Extras 四个部分，很多情况下后面三部分都是可省略的。</p><p>Options 部分用-作为前导符。其中许多命令的 Options 部分只包含单个字母，这时可以合并。例如:ls -lA和ls -l -A是等效的。Arguments 部分用来细化这个命令或指定这个命令具体的实施对象。Extras 部分则用来进一步实现其他功能。</p><p>例子：删除 QQ 这个程序。</p><p>some-pc:~ mac$ rm -R /Applications/QQ.app</p><p><strong>为什么要使用命令行/如何开启命令行？</strong></p><p>许多功能在图形界面不提供，只有通过命令行来实现。Finder会隐藏许多你不太会需要的文件，然而 command line 会允许你访问所有文件。通过 command line 可以远程访问你的 Mac（利用 SSH）。administrators 用户可以通过 sudo命令获得 root 用户权限。通过 command-line script 可以使工作更高效。Terminal（终端）程序可以在“实用工具”里找到。如果你开启手动输入用户名登录模式，登陆时在用户名处输入 &gt;console 可以直接进入命令行界面。随后你仍然需要登录到一个账户。</p><p><strong>关于 man 命令</strong></p><p>不管是mac还是linux都有很多命令，不可能熟练掌握所有命令，即使忘记了使用Google也能查到。mac最强大的一个命令应该算 man xxx ，Mac有上千条命令，每条命令还有许多可选参数和具体的使用方式，但是你却不需要记住这些命令。你只需要记住一个：man，查看具体的命令说明，想要推出直接键入q即可。</p><p>大多数命令都会包含一个使用指南，会告诉你任何你需要知道的关于这个命令的所有细节，在命令行中输入 man command-name即可获取。例如，你想知道ls这个命令怎么使用，输入man ls即可进入使用指南页面。使用指南往往很长，所以你可以使用▲（上箭头）或▼（下箭头）来上下移动，使用　来翻页，输入/和关键字来按照关键字搜索，按Q来退出使用指南页面。</p><p>那么——如果你连命令名称都不知道怎么办呢？输入man -k和关键字来对整个使用指南数据库进行搜索。</p><p><strong>MacOS 常用终端命令大全：</strong></p><p><strong>目录操作</strong></p><p>命令——功能描述——示例</p><p>mkdir——创建一个目录——mkdir dirname</p><p>rmdir——删除一个目录——rmdir dirname</p><p>mvdir——移动或重命名一个目录——mvdir dir1 dir2</p><p>cd——改变当前目录——cd dirname</p><p>pwd——显示当前目录的路径名——pwd</p><p>ls——显示当前目录的内容——ls -la</p><p>dircmp——比较两个目录的内容——dircmp dir1 dir2</p><p><strong>文件操作</strong></p><p>命令——功能描述——示例</p><p>cat——显示或连接文件————cat filename</p><p>pg分页格式化显示文件内容——pg filename</p><p>more——分屏显示文件内容——more filename</p><p>od——显示非文本文件的内容——od -c filename</p><p>cp——复制文件或目录——cp file1 file2</p><p>rm——删除文件或目录——rm filename</p><p>mv——改变文件名或所在目录——mv file1 file2</p><p>ln——联接文件——ln -s file1 file2</p><p>find——使用匹配表达式查找文件——find . -name “*.c” -print</p><p>file——显示文件类型——file filename</p><p>open——使用默认的程序打开文件——open filename（open . 打开当前目录）</p><p><strong>选择操作</strong></p><p>命令——功能描述——示例</p><p>head——显示文件的最初几行——head -20 filename</p><p>tail——显示文件的最后几行——tail -15 filename</p><p>cut——显示文件每行中的某些域——cut -f1,7 -d: /etc/passwd</p><p>colrm——从标准输入中删除若干列——colrm 8 20 file2</p><p>paste——横向连接文件——paste file1 file2</p><p>diff——比较并显示两个文件的差异——diff file1 file2</p><p>sed————非交互方式流编辑器——sed “s/red/green/g” filename</p><p>grep——在文件中按模式查找——grep “^[a-zA-Z]” filename</p><p>awk——在文件中查找并处理模式——awk ‘{print 111}’ filename</p><p>sort——排序或归并文件——sort -d -f -u file1</p><p>uniq——去掉文件中的重复行——uniq file1 file2</p><p>comm——显示两有序文件的公共和非公共行——comm file1 file2</p><p>wc——统计文件的字符数、词数和行数——wc filename</p><p>nl——给文件加上行号——nl file1 &gt;file2</p><p><strong>安全操作</strong></p><p>命令——功能描述——示例</p><p>passwd——修改用户密码——passwd</p><p>chmod——改变文件或目录的权限——chmod ug+x filename</p><p>umask————定义创建文件的权限掩码——umask 027</p><p>chown——改变文件或目录的属主——chown newowner filename</p><p>chgrp——改变文件或目录的所属组——chgrp staff filename</p><p>xlock——给终端上锁——xlock -remote</p><p><strong>编程操作</strong></p><p>命令——功能描述——示例</p><p>make——维护可执行程序的最新版本——make</p><p>touch——更新文件的访问和修改时间——touch -m 05202400 filename</p><p>dbx——命令行界面调试工具——dbx a.out</p><p>xde——图形用户界面调试工具——xde a.out</p><p><strong>进程操作</strong></p><p>命令——功能描述——示例</p><p>ps——显示进程当前状态——ps u</p><p>kill——终止进程——kill -9 30142</p><p>nice——改变待执行命令的优先级——nice cc -c *.c</p><p>renice——改变已运行进程的优先级——renice +20 32768</p><p><strong>时间操作</strong></p><p>命令——功能描述——示例</p><p>date——显示系统的当前日期和时间——date</p><p>cal——显示日历——cal 8 1996</p><p>time——统计程序的执行时间——time a.out</p><p><strong>网络与通信操作</strong></p><p>命令——功能描述——示例</p><p>telnet——远程登录——telnet hpc.sp.net.edu.cn</p><p>rlogin——远程登录——rlogin hostname -l username</p><p>rsh——在远程主机执行指定命令——rsh f01n03 date</p><p>ftp——在本地主机与远程主机之间传输文件——ftp ftp.sp.net.edu.cn</p><p>rcp——在本地主机与远程主机 之间复制文件——rcp file1 host1:file2</p><p>ping——给一个网络主机发送 回应请求——ping hpc.sp.net.edu.cn</p><p>mail——阅读和发送电子邮件——mail</p><p>write——给另一用户发送报文——write username pts/1</p><p>mesg——允许或拒绝接收报文——mesg n</p><p><strong>Korn Shell 命令</strong></p><p>命令——功能描述——示例</p><p>history——列出最近执行过的 几条命令及编号——history</p><p>r——重复执行最近执行过的 某条命令——r -2</p><p>alias——给某个命令定义别名——alias del=rm -i</p><p>unalias——取消对某个别名的定义——unalias del</p><p><strong>其它命令</strong></p><p>命令——功能描述——示例</p><p>uname——显示操作系统的有关信息——uname -a</p><p>clear——清除屏幕或窗口内容——clear</p><p>env——显示当前所有设置过的环境变量——env</p><p>who——列出当前登录的所有用户——who</p><p>whoami——显示当前正进行操作的用户名——whoami</p><p>tty——显示终端或伪终端的名称——tty</p><p>stty——显示或重置控制键定义——stty -a</p><p>du——查询磁盘使用情况——du -k subdir</p><p>df——显示文件系统的总空间和可用空间——df /tmp</p><p>w——显示当前系统活动的总信息——w</p><p><strong>一些常用技巧</strong></p><p>所以你可以使用▲（上箭头）或▼（下箭头）来上下移动，使用　空格键 来翻页，输入/和关键字来按照关键字搜索按Q来退出使用指南页面tab按键自动补全唯一路径中止一个错误的或者发疯的命令，可以使用组合键control + C。你可以在执行前编辑命令，只需要使用箭头和键盘上的其他字母。没有输入任何命令时，你可以用▲和▼来浏览历史命令。同样可以编辑和再次执行。你也可以使用history命令查看历史记录。你可以使用组合键control + L清屏。<br>命令+N:打开一个新的窗口;命令+T:在一个新窗口中建立多个终端窗口.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是 Mac 还是 Linux 命令，通常从命令名称就可以看出其功能。但是常用终端命令很多，不可能熟练掌握所有命令。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>SUNSHINE-SMILE</title>
    <link href="http://yoursite.com/2020/02/20/SUNSHINE-SMILE/"/>
    <id>http://yoursite.com/2020/02/20/SUNSHINE-SMILE/</id>
    <published>2020-02-20T15:18:33.000Z</published>
    <updated>2020-02-28T12:31:36.610Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一五计划</p><p>学历封顶.<br>有车有房.<br>2020年<br>1.每个月肯一部技术书籍的大部头,并写博客总结.<br>2.到4月底能够单独接项目做兼职.<br>3.做事有计划,事后有总结,及时复盘.<br>4.雅思考个较高的分数.<br>5.每天阅读一篇英文文章.<br>6.完美英音.<br>7.德语阅读文章无障碍.<br>8.每周更新技术博客.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;一五计划&lt;/p&gt;
&lt;p&gt;学历封顶.&lt;br&gt;有车有房.&lt;br&gt;2020年&lt;br&gt;1.每个月肯一部技术书籍的大部头,并写博客总结.&lt;br&gt;2.到4月底能够单独接项目做兼职.&lt;br&gt;3.做事有计划,事后有总结,及时复盘.&lt;br&gt;4.雅思考个较高的分数.&lt;br&gt;5.每天阅
      
    
    </summary>
    
    
    
      <category term="个人计划" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Shortcuts-of-Mac</title>
    <link href="http://yoursite.com/2020/02/20/Shortcuts-of-Mac/"/>
    <id>http://yoursite.com/2020/02/20/Shortcuts-of-Mac/</id>
    <published>2020-02-20T13:47:05.000Z</published>
    <updated>2020-02-28T12:29:58.403Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://github.com/AlexYangZ/image-store/raw/master/Mac-shortcuts/Mac%20Keyboard.jpg" alt="Oops.." title="Lucky"><br>在Mac中快捷键的图形符号：</p><ul><li>⇧ =&gt; Shift</li><li>⌃ =&gt; Ctrl</li><li>⌘ =&gt; Command</li><li>⌥ =&gt; Alt<a id="more"></a><h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2></li></ul><p>快速打开Finder</p><ul><li>在桌面时使用<code>Command+N</code></li><li>在桌面使用<code>Option+Command+空格</code></li></ul><p>显示启动台：<code>Option+D</code></p><p>显示桌面：<code>Command+D</code></p><p>将焦点移动到程序坞：<code>Option+Q</code></p><p>将焦点移动到菜单栏：<code>Option+W</code></p><p>使用有道翻译选中查词：<code>Ctrl+Commamd+X</code></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="基础的快捷键"><a href="#基础的快捷键" class="headerlink" title="基础的快捷键"></a>基础的快捷键</h3><ul><li>Command-T 打开新标签页</li><li>Command-W 关闭最前面的窗口</li><li>Command-H 隐藏最前面的应用窗口</li><li>Command-M 将最前面的窗口最小化至程序坞</li><li>Control-Command–F 将应用全屏显示</li><li>Command+Tab 切换窗口</li><li>Command-逗号 (,) 打开应用的偏好设置</li><li>Command+空格 聚焦搜索</li><li><strong>Control–上箭头</strong>：显示调度中心。</li><li><strong>Control–下箭头</strong>：显示最前面的应用的所有窗口。</li></ul><h3 id="Finder中"><a href="#Finder中" class="headerlink" title="Finder中"></a>Finder中</h3><ul><li><strong>Shift-Command-D</strong>：打开“桌面”文件夹。</li><li><strong>Option-Command-L</strong>：打开“下载”文件夹。</li><li><strong>Shift-Command-O</strong>：打开“文稿”文件夹。</li><li><strong>Shift-Command-N：</strong>新建文件夹。</li><li><strong>Command-1</strong>：以图标方式显示“访达”窗口中的项目。</li><li><strong>Command-2</strong>：以列表方式显示“访达”窗口中的项目。</li><li><strong>Command-3</strong>：以分栏方式显示“访达”窗口中的项目。</li><li><strong>Command-4</strong>：以封面流方式显示“访达”窗口中的项目。</li><li><strong>Command–左中括号 ([)</strong>：前往上一个打开的文件夹。</li><li><strong>Command–右中括号 (])</strong>：前往下一个打开的文件夹。</li><li><strong>Command–上箭头</strong>：打开当前文件的上一级目录（返回上一级）。</li><li><strong>Command-Delete</strong>：将所选项移到废纸篓。</li></ul><h3 id="浏览器中"><a href="#浏览器中" class="headerlink" title="浏览器中"></a>浏览器中</h3><ul><li>Control-Tab 转向下一个标签页　</li><li>Control-Shift-Tab 转向上一个标签页　　　</li><li>Command-L 光标直接跳至地址栏　</li><li>Command+R 刷新页面　</li></ul><h2 id="基本的快捷键"><a href="#基本的快捷键" class="headerlink" title="基本的快捷键"></a>基本的快捷键</h2><h3 id="基础快捷键"><a href="#基础快捷键" class="headerlink" title="基础快捷键"></a>基础快捷键</h3><ul><li><p>Command-X 剪切</p></li><li><p>Command-C 拷贝</p></li><li><p>Command-V 粘贴</p></li><li><p>Command-A 全选</p></li><li><p>Command-F 查找</p></li><li><p>Command-G 向下查找</p><blockquote><p>Shift-Command-G 向上查找</p></blockquote></li><li><p>Command-H 隐藏最前面的应用窗口</p><blockquote><p>Option-Command-H 产看最前面的应用但隐藏所有其他应用</p></blockquote></li><li><p>Command-M 将最前面的窗口最小化至程序坞</p></li><li><p>Command-O 打开选择文件</p></li><li><p>Command-P 打印</p></li><li><p>Command-S 保存</p></li><li><p>Command-T 打开新标签页</p></li><li><p>Command-W 关闭最前面的窗口</p><blockquote><p>Option-Command-W 关闭所有应用窗口</p></blockquote></li><li><p>Command+空格 聚焦搜索</p></li><li><p>Control-Command–空格键 选择表情和其他符号</p></li><li><p>Control-Command–F 将应用全屏显示</p></li><li><p>空格键 快速预览</p></li><li><p>Command+Tab 切换窗口</p></li><li><p>Shift-Command-5 截图或录屏</p></li><li><p>Shift-Command-N 在Finder中创建文件夹</p></li><li><p>Command-逗号 (,) 打开应用的偏好设置</p></li></ul><h3 id="Finder和系统快捷键"><a href="#Finder和系统快捷键" class="headerlink" title="Finder和系统快捷键"></a>Finder和系统快捷键</h3><ul><li><p>Command-D 复制所选文件</p></li><li><p>Command-E 推出所选磁盘或宗卷</p></li><li><p>Command-F 在“访达”窗口中开始“聚焦”搜索</p></li><li><p>Command-I 显示所选文件的简介</p></li><li><p><strong>Shift-Command-C</strong>：打开“电脑”窗口。</p></li><li><p><strong>Shift-Command-D</strong>：打开“桌面”文件夹。</p></li><li><p><strong>Shift-Command-F</strong>：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。</p></li><li><p><strong>Shift-Command-G</strong>：打开“前往文件夹”窗口。</p></li><li><p><strong>Shift-Command-H</strong>：打开当前 macOS 用户帐户的个人文件夹。</p></li><li><p><strong>Shift-Command-I</strong>：打开 iCloud 云盘。</p></li><li><p><strong>Option-Command-L</strong>：打开“下载”文件夹。</p></li><li><p><strong>Shift-Command-N：</strong>新建文件夹。</p></li><li><p><strong>Shift-Command-O</strong>：打开“文稿”文件夹。</p></li><li><p><strong>Ctrl-Shift-Command-T</strong>：将所选的“访达”项目添加到“程序坞”</p></li><li><p><strong>Option-Command-D</strong>：显示或隐藏“程序坞”。</p></li><li><p><strong>Control-Command-T</strong>：将所选项添加到边栏</p></li><li><p><strong>Command–斜线 (/)</strong>：隐藏或显示“访达”窗口中的状态栏。</p></li><li><p><strong>Command-J</strong>：显示“显示”选项。</p></li><li><p><strong>Command-N</strong>：打开一个新的“访达”窗口。</p></li><li><p><strong>Command-T</strong>：新建Finder标签页。</p></li><li><p><strong>Option-Command-V</strong>：移动：将剪贴板中的文件从原始位置移动到当前位置。</p></li><li><p><strong>Command-1</strong>：以图标方式显示“访达”窗口中的项目。</p></li><li><p><strong>Command-2</strong>：以列表方式显示“访达”窗口中的项目。</p></li><li><p><strong>Command-3</strong>：以分栏方式显示“访达”窗口中的项目。</p></li><li><p><strong>Command-4</strong>：以封面流方式显示“访达”窗口中的项目。</p></li><li><p><strong>Command–左中括号 ([)</strong>：前往上一个打开的文件夹。</p></li><li><p><strong>Command–右中括号 (])</strong>：前往下一个打开的文件夹。</p></li><li><p><strong>Command–上箭头</strong>：打开当前文件的上一级目录（返回上一级）。</p><blockquote><p><strong>Command–Control–上箭头</strong>：在新窗口中打开包含当前文件夹的文件夹。</p></blockquote></li><li><p><strong>Command–下箭头</strong>：打开所选项。</p></li><li><p><strong>右箭头</strong>：打开所选文件夹。这个快捷键仅在列表视图中有效。</p></li><li><p><strong>左箭头</strong>：关闭所选文件夹。这个快捷键仅在列表视图中有效。</p></li><li><p><strong>Command-Delete</strong>：将所选项移到废纸篓。</p></li><li><p><strong>Control–上箭头</strong>：显示调度中心。</p></li><li><p><strong>Control–下箭头</strong>：显示最前面的应用的所有窗口。</p></li><li><p><strong>按住 Command 键拖移到另一个宗卷</strong>：将拖移的项目移到另一个宗卷，而不是拷贝它。</p></li></ul><h3 id="文本处理中"><a href="#文本处理中" class="headerlink" title="文本处理中　"></a>文本处理中　</h3><ul><li>Fn-上箭头 向上滚动一页（Page Up）　　</li><li>Fn-下箭头 向下滚动一页（Page Down）　　</li><li>Fn-左箭头 滚动至文稿开头（Home）　　</li><li>Fn-右箭头 滚动至文稿末尾（End）　</li><li>Command-右箭头 将光标移至当前行的行尾　　</li><li>Command-左箭头 将光标移至当前行的行首　　</li><li>Command-下箭头 将光标移至文稿末尾　　</li><li>Command-上箭头 将光标移至文稿开头</li><li>Option-右箭头 将光标移至下一个单词的末尾　　</li><li>Option-左箭头 将光标移至上一个单词的开头　</li><li>Command+R 刷新</li><li>Delete 删除光标后面的内容</li></ul><h3 id="在浏览器中"><a href="#在浏览器中" class="headerlink" title="在浏览器中"></a>在浏览器中</h3><ul><li>Control-Tab 转向下一个标签页　</li><li>Control-Shift-Tab 转向上一个标签页　　　</li><li>Command-L 光标直接跳至地址栏　　</li><li>Command-加号或等号 放大页面　　</li><li>Command-减号 缩小页面</li><li>Command+R 刷新页面</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/AlexYangZ/image-store/raw/master/Mac-shortcuts/Mac%20Keyboard.jpg&quot; alt=&quot;Oops..&quot; title=&quot;Lucky&quot;&gt;&lt;br&gt;在Mac中快捷键的图形符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⇧ =&amp;gt; Shift&lt;/li&gt;
&lt;li&gt;⌃ =&amp;gt; Ctrl&lt;/li&gt;
&lt;li&gt;⌘ =&amp;gt; Command&lt;/li&gt;
&lt;li&gt;⌥ =&amp;gt; Alt
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>新建本地仓库并将代码提交到远程仓库</title>
    <link href="http://yoursite.com/2020/02/16/%E6%96%B0%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%B9%B6%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2020/02/16/%E6%96%B0%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%B9%B6%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2020-02-16T06:07:29.000Z</published>
    <updated>2020-02-28T12:53:25.010Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/AlexYangZ/image-store/raw/master/article1-remote-local-established/061501440489501.png" alt="Oops.." title="Beauty"></p><h2 id="前提：在github上手动创建仓库image-store。"><a href="#前提：在github上手动创建仓库image-store。" class="headerlink" title="前提：在github上手动创建仓库image-store。"></a>前提：在github上手动创建仓库image-store。</h2><p>p.s. : 需要先在github手动创建repo</p><p>Create a new repository on the command line</p><blockquote><p>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin <a href="https://github.com/yourId/repoName.git" target="_blank" rel="noopener">https://github.com/yourId/repoName.git</a><br>git push -u origin master`</p></blockquote><a id="more"></a><p>Push an existing repository from the command line</p><blockquote><p>git remote add origin <a href="https://github.com/yourID/repoName.git" target="_blank" rel="noopener">https://github.com/yourID/repoName.git</a><br>git push -u origin master</p></blockquote><h2 id="将本地仓库提交至远程仓库"><a href="#将本地仓库提交至远程仓库" class="headerlink" title="将本地仓库提交至远程仓库"></a>将本地仓库提交至远程仓库</h2><p>在本地按照如下的命令进行</p><p>1、 mkdir image-store#如果是已存在的工程项目，则直接cd到项目根目录下，不需要新建。</p><p>2、 cd image-store</p><p>3、 git init #初始化本地仓库</p><p>4、 git add xxx #添加要push到远程仓库的文件或文件夹</p><p>5、 git commit -m ‘first commit’</p><p>6、 git remote add origin <a href="https://github.com/yourgithubID/image-store.git" target="_blank" rel="noopener">https://github.com/yourgithubID/image-store.git</a> #建立远程仓库</p><p>7、 git push -u origin master #将本地仓库push到远程仓库</p><p>需要注意的是：一定要在github上手动创建仓库image-store，否则会出现错误。</p><p>在实践过程中，由于在github上手动创建的仓库包括：README.md文件，二本地仓库没有此文件，则在执行git push -u origin master命令时报如下的错误。<br><img src="https://github.com/AlexYangZ/image-store/raw/master/article1-remote-local-established/1.png" alt="Oops.." title="first"></p><h3 id="解决方案一-出现错误的主要原因是github中的README-md文件不在本地代码目录中-可以通过如下命令进行代码合并【注：pull-fetch-merge"><a href="#解决方案一-出现错误的主要原因是github中的README-md文件不在本地代码目录中-可以通过如下命令进行代码合并【注：pull-fetch-merge" class="headerlink" title="解决方案一:出现错误的主要原因是github中的README.md文件不在本地代码目录中,可以通过如下命令进行代码合并【注：pull=fetch+merge]"></a>解决方案一:出现错误的主要原因是github中的README.md文件不在本地代码目录中,可以通过如下命令进行代码合并【注：pull=fetch+merge]</h3><p>git pull –rebase origin master</p><p>执行上面代码后可以看到本地代码库中多了README.md文件<br><img src="https://github.com/AlexYangZ/image-store/raw/master/article1-remote-local-established/2.png" alt="Oops.." title="second"></p><p>第二步：此时再执行语句 git push -u origin master即可完成代码上传到github<br><img src="https://github.com/AlexYangZ/image-store/raw/master/article1-remote-local-established/3.png" alt="Oops.." title="third"></p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二:"></a>解决方案二:</h3><p>1、git pull origin master –allow-unrelated-histories //把远程仓库和本地同步，消除差异</p><p>2、重新add和commit相应文件</p><p>3、git push origin master</p><p>4、此时就能够上传成功了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/AlexYangZ/image-store/raw/master/article1-remote-local-established/061501440489501.png&quot; alt=&quot;Oops..&quot; title=&quot;Beauty&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前提：在github上手动创建仓库image-store。&quot;&gt;&lt;a href=&quot;#前提：在github上手动创建仓库image-store。&quot; class=&quot;headerlink&quot; title=&quot;前提：在github上手动创建仓库image-store。&quot;&gt;&lt;/a&gt;前提：在github上手动创建仓库image-store。&lt;/h2&gt;&lt;p&gt;p.s. : 需要先在github手动创建repo&lt;/p&gt;
&lt;p&gt;Create a new repository on the command line&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git init&lt;br&gt;git add README.md&lt;br&gt;git commit -m “first commit”&lt;br&gt;git remote add origin &lt;a href=&quot;https://github.com/yourId/repoName.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yourId/repoName.git&lt;/a&gt;&lt;br&gt;git push -u origin master`&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>C++GettingStarted1</title>
    <link href="http://yoursite.com/2020/02/06/C-GettingStarted1/"/>
    <id>http://yoursite.com/2020/02/06/C-GettingStarted1/</id>
    <published>2020-02-06T15:46:23.000Z</published>
    <updated>2020-02-22T09:19:28.366Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.</strong>当main函数return回的是-1时echo #?状态是255;当main函数return回的是0时echo #?状态是0.<br>g++ -o pro1 pro1.cc</p><blockquote><p>alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  461  22:    30:28<br>alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  462  22    :32:50<br> pro1.cc<br> alexyang@bogon  ~/Desktop/C++Learn  cc pro1.cc          ✔  463  22    :33:06<br>alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  464  22    :33:25<br>a.out   pro1.cc<br>alexyang@bogon  ~/Desktop/C++Learn  ./a.out             ✔  465  22    :33:31<br>alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  466  22    :34:13<br>0<br>alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc<br> alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  483  22:44:39<br>a.out   pro1    pro1.cc<br> alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  484  22:45:14<br> alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  485  22:45:34<br>0<br> alexyang@bogon  ~/Desktop/C++Learn  vim pro1            ✔  486  22:45:59<br> alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  487  22:46:54<br>alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc<br>    pro1.cc:3:2: error: use of undeclared identifier ‘std’<br>     26         std::cout &lt;&lt; “Hello, World!”&lt;&lt; std::endl;<br>     27         ^<br>    pro1.cc:3:33: error: use of undeclared identifier ‘std’<br>        std::cout &lt;&lt; “Hello, World!”&lt;&lt; std::endl;<br>                           ^<br>    2 errors generated.<br> alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc       1 ↵  489  22:50:23<br> alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc<br> alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  491  22:52:18<br>Hello, World!<br> alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  492  22:52:26<br>0<br> alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  493  22:52:52<br> alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc<br> alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  495  22:54:06<br>Hello, World!<br> alexyang@bogon  ~/Desktop/C++Learn  echo $?         255 ↵  496  22:54:21<br>255</p></blockquote><a id="more"></a><h2 id="二"><a href="#二" class="headerlink" title="二."></a>二.</h2><p>1.Writing std::cout uses the scope operator (the :: operator) to say that we want to use the name cout that is defined in the namespace std.<br>2.The input operator (the &gt;&gt; operator) behaves analogously to the output operator.  Some Words : asterisk italicize  indent<br>3.Reading an Unkown Number of Input<br>while (std::cin &gt;&gt; value)<br>On Windows systems we enter an end-of-file by typing a control-z–hold down the Ctrl key and press z–followed by hittingeither the Enter or Return key. On UNIX systems, including on Mac OS X machines, end-of-file is usually control-d.<br>4.Headers from the standard library are enclosed in angle brackets (&lt; &gt;). Those that are not part of the library are enclosed in double quotes(“ “).<br>5.Member functions are sometimes referred to as methods.</p><ol start="6"><li><p>$ addItems <infile>outfile    Assuming $ is the system prompt and our addition program has been compiled into an executablefile named addItems.exe(or addItems on UNIX systems), this command will read transactions from a file named infile and write its output to a file named outfile in the current directory.</infile></p><p> #include <iostream><br> #include “Sales_item.h”</iostream></p><p> int main()<br> {</p><pre><code>Sales_item total; // variable to hold data for the next transaction// read the first transaction and ensure that there are data to processif (std::cin &gt;&gt; total) {    Sales_item trans; // variable to hold the running sum// read and process the remaining transactionswhile (std::cin &gt;&gt; trans) {        // if we&apos;re still processing the same book    if (total.isbn() == trans.isbn())     total += trans; // update the running total     else {                      // print results for the previous book     std::cout &lt;&lt; total &lt;&lt; std::endl;      total = trans;  // total now refers to the next book    }    }std::cout &lt;&lt; total &lt;&lt; std::endl; // print the last transaction} else {// no input! warn the userstd::cerr &lt;&lt; &quot;No data?!&quot; &lt;&lt; std::endl;return -1;  // indicate failure}return 0;</code></pre><p> }</p></li></ol><hr><h3 id="7-vim小技巧"><a href="#7-vim小技巧" class="headerlink" title="7.vim小技巧:"></a>7.vim小技巧:</h3><p>  Vim多行缩进技巧:按v进入visual状态，选择多行，用&gt;或&lt;缩进或缩出<br>  在使用vim时，当我们以普通用户去打开一个只有root用户才有权限操作的文件时，我们编辑完成之后，正要保存，却发现，这个文件我们没有权限修改。解决方案：底行命令模式执行：:w !sudo tee %<br>上述方式非常完美的解决了不能保存只读文件的问题，但毕竟命令还是有些长，为了避免每次输入一长串的命令，可以将它映射为一个简单的命令加到 .vimrc 中：</p><blockquote><p>“ Allow saving of files as sudo when I forgot to start vim using sudo.<br>cmap w!! w !sudo tee &gt; /dev/null %</p></blockquote><p>这样，简单的运行:w!!即可。命令后半部分&gt; /dev/null作用为显式的丢掉标准输出的内容。</p><p>sh-3.2# mv Blog-Images/image-store/ ./  #将该文件夹移至和当前目录平级.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一.&lt;/strong&gt;当main函数return回的是-1时echo #?状态是255;当main函数return回的是0时echo #?状态是0.&lt;br&gt;g++ -o pro1 pro1.cc&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  461  22:    30:28&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  462  22    :32:50&lt;br&gt; pro1.cc&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  cc pro1.cc          ✔  463  22    :33:06&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  464  22    :33:25&lt;br&gt;a.out   pro1.cc&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  ./a.out             ✔  465  22    :33:31&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  466  22    :34:13&lt;br&gt;0&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  ls                  ✔  483  22:44:39&lt;br&gt;a.out   pro1    pro1.cc&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  484  22:45:14&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  485  22:45:34&lt;br&gt;0&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  vim pro1            ✔  486  22:45:59&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  487  22:46:54&lt;br&gt;alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc&lt;br&gt;    pro1.cc:3:2: error: use of undeclared identifier ‘std’&lt;br&gt;     26         std::cout &amp;lt;&amp;lt; “Hello, World!”&amp;lt;&amp;lt; std::endl;&lt;br&gt;     27         ^&lt;br&gt;    pro1.cc:3:33: error: use of undeclared identifier ‘std’&lt;br&gt;        std::cout &amp;lt;&amp;lt; “Hello, World!”&amp;lt;&amp;lt; std::endl;&lt;br&gt;                           ^&lt;br&gt;    2 errors generated.&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc       1 ↵  489  22:50:23&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  491  22:52:18&lt;br&gt;Hello, World!&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  echo $?             ✔  492  22:52:26&lt;br&gt;0&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  vim pro1.cc         ✔  493  22:52:52&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  g++ -o pro1 pro1.cc&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  ./pro1              ✔  495  22:54:06&lt;br&gt;Hello, World!&lt;br&gt; alexyang@bogon  ~/Desktop/C++Learn  echo $?         255 ↵  496  22:54:21&lt;br&gt;255&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>To-Be-a-Vimer</title>
    <link href="http://yoursite.com/2020/01/25/To-Be-a-Vimer/"/>
    <id>http://yoursite.com/2020/01/25/To-Be-a-Vimer/</id>
    <published>2020-01-25T03:34:00.000Z</published>
    <updated>2020-02-28T12:24:08.037Z</updated>
    
    <content type="html"><![CDATA[<p>Visual(可视)模式<br>Visual模式一般用来块状选择文本<br>Normal模式下使用v进入visual选择<br>使用V选择行◆使用ctrl+v进行方块选择</p><a id="more"></a><p>Command(命令)模式<br>Normal模式下输入:之后执行命令，比如保存退出:wq 一气呵成◆顾名思义，执行Vim命令,比如保存:w,退出:q<br>◆比如分屏:vs (vertical split), :sp(split)<br>◆比如使用:% s/foo/bar/g全局替换<br>/单词      搜索.              Y复制p粘贴</p><p>代码就像人生，总是经常出错,需要我们快速修正<br>◆进入Vim之后首先使用a/i/o之一进入插入模式<br>◆ctrl+h 删除上一个字符, ctrl+w删除上一个单词, ctrl+ u删除当前行<br>gi快速跳转到最后一次编辑的地方并进入插入模式</p><p>在单词之间厂飞舞」<br>在单词之间移动是我们浏览操作中最常使用的命令<br>◆w/W移到下一个word/WORD开头。e/E 下一个word/WORD尾◆b/B回到上一个word/WORD开头,可以理解为backword<br>◆ word指的是以非空白符分割的单词, WORD以空白符分割的单词</p><p>行间搜索移动<br>同一行快速移动的方式其实是搜索一个字符并且移动到该字符<br>◆使用f{char}可以移动到char字符上, t移动到char的前一个字符◆如果第一次没搜到,可以用分号(;)/逗号(,)继续搜该行下一个/上一个◆大写的F表示反过来搜前面的字符</p><p>Vim水平移动<br>如何快速移动到一行的行首或者行尾呢?<br>◆0移动到行首第一个字符，^移动到第一个非空白字符◆$移动到行尾，g_移动到行尾非空白字符<br>◆记住常用的0和$就可以满足日常需求了</p><p>Vim垂直移动<br>我们还可以在句子(sentence)和段落(paragraph)间移动(不常用)◆使用括号( )在句子间移动,你可以用:help (来查看帮助<br>◆使用{}在段落之间移动<br>◆插件章节我们会讲如何用easy一motion插件移动 ,这些命令就都不用记忆啦</p><p>Vim页面移动<br>翻页命令太多, 2/8定律,记住常见的就能满足需求<br>◆gg/G移动到文件开头和结尾,你可以使用ctrl+o快速返回<br>◆H/M/L跳转到屏幕的开头(Head) ,中间(Middle)和结尾(L ower)◆Ctrl+u. ctrl+f.上”下翻页. (upword/forward)。zz 把屏幕置为中间</p><p>Vim快速删除<br>如何快速删除一个字符或者单词呢?<br>◆Vim在normal模式下使用x快速删除一个字符<br>◆使用d (delete)配合文本对象快速删除一个单词 daw (d aroundword) diw dw dd dt) d0 d$<br>◆d和x都可以搭配数字来执行多次</p><p>Vim快速修改<br>相比删除,更常用修改,一般是删除之后改成我们期望的文本<br>◆常用有三个, r (replace) , c (change) , s(substitute)亦可和数字界和使用<br>normal模式下使用r可以替换一个字符。s替换并进入插入模式<br>使用c配合文本对象,我们可以快速进行修改.caw.R直接往下不断替换字符.S整行删除进入插入模式.C整行删除进入插入模式 caw ct)<br>插入模式小技巧Ctl +h/w回退字符/单词</p><p>Vim查询<br>查询单词也是一个常用操作<br>◆使用/或者?进行前向或者反向搜索    :set hls将搜索结果高亮  :set incsearch增量搜索:边搜索边进行高亮<br>◆使用n/N跳转到下一个或者上一个匹配<br>◆使用*或者#进行当前单词的前向和后向匹配</p><p>Vim替换命令<br>substitute命令允许我们查找并且替换掉文本,并且支持正则式<br>◆:[range]s[ubstitute]/{pattern}/{string}/[flags]<br>◆range表示范围比如:10, 20表示10一20行，%表示全部<br>◆pattern是要替换的模式, string是替换后文本</p><p>替换标志位<br>Flags有几个常用的标志<br>◆g(globa)表示全局范围内执行<br>◆c(confirm)表示确认 ,可以确认或者拒绝修改<br>◆n(number)报告匹配到的次数而不替换,可以用来查询匹配次数.    :1,6 s/self//n<br> :% s/&lt;quack&gt;/jiao/g    精确替换。  正则表达式<br>U :undo.  Ctl +r:  </p><p>Buffer Window Tab<br>我们先来介绍几个多文件操作相关的概念<br>◆Buffer是指打开的一个文件的内存缓冲区<br>◆窗口是Buffer可视化的分割区域<br>◆Tab 可以组织窗口为一个工作区</p><p>Buffer一什么是缓冲区?<br>◆Vim 打开一个文件后会加载文件内容到缓冲区,之 后的修改都是针对内存中的缓冲区,并不会直接保存到文件,直到我们执行:w (write)的时候才会把修改内容写入到文件里</p><p>Buffer切换<br>那如何在buffer之间切换呢?<br>◆使用:Is会列举当前缓冲区,然后使用:b n跳转到第n个缓冲区<br>◆ :bpre :bnext :bfirst :blast<br>◆或者用:b buffer_name加上tab补全来跳转</p><p>:e b.txt           :vs d.txt<br>:ls 查看缓冲区。 :b 1跳转a文件进行编辑</p><p>Window窗口<br>窗口是可视化的分割区域<br>◆一个缓冲区可以分割成多个窗口,每个窗口也可以打开不同缓冲区<br>◆&lt;Ctrl+w&gt;s 水平分割，&lt;Ctrl+w&gt;v 垂直分割。或者:sp 和:vs<br>◆每个窗口可以继续被无限分割(看你屏幕是否够大)</p><p>如何切换窗口<br>切换窗口的命令都是使用Ctrl+ w (window)作为前缀<br>命令<br>用途<br>&lt;C一W&gt;W<br>在窗口间循环切换<br>&lt;C 一W&gt;h<br>切换到左边的窗口<br>&lt;C一W&gt; j<br>切换到下边的窗口<br>&lt;C一w&gt;k<br>切换到上边的窗口<br>&lt;C 一W&gt;l     L.    移动窗口<br>切换到右边的窗口</p><p>如何重排窗口?<br>重排窗口可以改变窗口的大小:h window一resize查看文档<br>&lt;C一W&gt;=  使所有窗口等宽、等高<br>&lt;C一W&gt;_  最大化活动窗口的高度<br>&lt;C一W&gt;  最大化活动窗口的宽度<br>[N]&lt;C一W&gt;  把活动窗口的高度设为[N]行<br>[N]&lt;C一w&gt;|  把活动窗口的宽度设为[N]列</p><p>Tab(标签页)将窗口分组<br>Tab是可以容纳一系列窗口的容器(:h tabpage)<br>◆Vim的Tab和其他编辑器不太一样,可以想象成Linux的虚拟桌面◆比如一个Tab全用来编辑Python文件, 一个Tab全是HTML文件◆相比窗口, Tab一般用的比较少, Tab太多管理起来也比较麻烦</p><dl><dt>Tab(标签页)操作<br>Tab使用不多,简单了解一下常用操作就好<br>命令<br>用途<br>: tabe[dit] {filename}<br>在新标签页中打开{filename}<br>&lt;C 一W&gt;T<br>把当前窗口移到一个新标签页<br>. : tabc [lose ]<br>关闭当前标签页及其中的所有窗口</dt><dd>tabo [nly]<br>只保留活动标签页，关闭所有其他标签页</dd></dl><dl><dt>Tab(标签页)切换操作<br>如何切换不同的标签页, 一般建立两个就好,太多不好操作<br>Ex命令<br>普通模式命令<br>用途<br>: tabn[ext] {N}<br>{N}gt<br>切换到编号为{N}的标签页<br>: tabn [ext]<br>gt<br>切换到下一标签页</dt><dd>tabp [revious]<br>gT<br>切换到上一标签页<br>:tabnew duck.py</dd></dl><p>◆窗口分割可以非常方便地查看代码,比如查看整个调用链<br>◆延伸 :插件篇我们会配合ctrlp插件和nerdtree快速操作多个文件</p><p>Text Object(文本对象)<br>如果你学过主流的编程语言, 一定知道面向对象编程<br>◆Vim里文本也有对象的概念,比如一个单词，一段句子,一个段落<br>◆很多其他编辑器经常 只能操作单个字符来修改文本,比较低效<br>◆通过操作文本对象来修改要比只操作单个字符高效</p><p>文本对象操作方式<br>之前我们已经使用过文本对象了,回忆下dw (删除一个单词)<br>◆[number]&lt; command&gt; [text object]<br>◆number 表示次数, command是命令,d(elete), c(hange), y(yank)<br>◆text object是要操作的文本对象,比如单词w ,句子s ,段落p .</p><p>通过示例来学习<br>iw表示inner word.如果键入viw命令，那么首先v将进入选择模式，然后iw将选中当前单词。<br>aw表示around word,它不但会选中当前单词，还会包含当前单词之后的空格。<br>以下实例中的红色[ ]表示作用范围:<br>iw<br>This is a [test] sentence.<br>aw<br>This is a [test ]sentence.<br>iW<br>This is a [..test..] sentence.<br>aW<br>This is a [..test… ]sentence.</p><p>通过示例来学习<br>i( or i) 1<em>([2 + 3])<br>a(ora) 1</em> *[(2 + 3)].    包含圆括号本身</p><p>课后练习<br>摆脱低效的字符操作,使用文本对象提升效率<br>◆回忆下如何删除一个单词 ?<br>◆在你的Vim中尝试使用文本对象快速增,删,改一个单词<br>◆延伸:有些插件扩展了文本对象,比如vim一go可以使用f表示一个函数</p><p>Vim Normal模式复制粘贴<br>初学者会感觉Vim复制粘贴比较奇怪,先从normal模式学习<br>◆ normal模式下复制粘贴分别使用y (yank)和p (put) ,剪贴d和p<br>◆我们可以使用v(visual)命 令选中所要复制的地方,然后使用p粘贴<br>◆配合文本对象:比如使用yiw复制一个单词, yy复制一行<br>Vim里的剪贴(cut)复制(copy)粘贴(paste)分别是delete/yank/put</p><p>Insert模式下的复制粘贴<br>很多人会使用鼠标进行选中,然后使用ctrl+v或者cmd +v粘贴<br>◆这个和其他的文本编辑器差不多,但是粘贴代码有个坑<br>◆很多人在vimrc中设置了autoindent ,粘贴Python代码缩进错乱<br>◆这个时候需要使用:set paste和:set nopaste解决</p><p>什么是Vim的寄存器?<br>你有没有好奇? Vim在normal模式下复制/剪贴的内容去了哪?<br>◆Vim里操作的是寄存器而不是系统剪贴板,这和其他编辑器不同<br>◆默认我们使用d删除或者y复制的内容都放到了“无名寄存器”<br>◆用x删除一个字符放到无名寄存器,然后p粘贴,可以调换俩字符</p><p>深入寄存器(register)<br>Vim不使用单一剪贴板进行剪贴、复制与粘贴,而是多组寄存器<br>◆通过”{register}前缀可以指定寄存器,不指定默认用无名寄存器<br>◆比如使用 ”ayiw复制一个单词到寄存器a中，”bdd删除当前行到寄存器b中<br>◆Vim中””表示无名寄存器,缺省使用。 “” p其实就等同p<br>“ayy<br>:reg a<br>Registers 一一<br>“a If the implenentation is hard to explain, it’s a bad idea,AJ<br>“byy<br>:reg b<br>Registers 一一<br>“b If the implementation is easy to explain, it may be a good idea.AJPress ENTER or type</p><p>“ap 引用a寄存器内容并粘贴</p><p>其他常见寄存器<br>除了有名寄存器a一z, Vim中还有一些其他常见寄存器<br>◆复制专用寄存器”0 使用y复制文本同时不仅会复制到无名寄存器还会被拷到复制寄存器0<br>◆系统剪贴板 “+可以在复制前加上“+复制到系统剪贴板.这样就可以在其他地方粘贴不再局限于vim<br>◆其他一些寄存器比如”% 当前文件名，”. 上次插入的文本<br>如何复制内容到系统剪切板 首先确保vim编译选项里面有clipboard<br>:echo has(‘ clipboard’ ) 查看,若输出1则支持该特性</p><p>Commond  x放到系统剪切板里面</p><p>:set clipboard=unnamed可以让你直接复制粘贴系统剪贴板内容<br>normal模式下可直接使用p进行粘贴.insert模式下粘贴系统剪贴板内容:crlR+<br>服务器上操作vim时没有系统剪切板这时</p><p>:e! 重新加载且不保存当前文件</p><p>课后练习<br>了解normal/insert模式复制粘贴的方法,常见寄存器的用法<br>◆现在找一段Python代码,尝试在Vim里粘贴进去<br>◆试试你能否将Vim 中的内容复制到系统剪贴板<br>◆尝试在服务器的 Vim.上粘贴下系统剪贴板的内容</p><p>从需求说起<br>从一个需求说起,给多行url链接加上双引号,你会怎么做呢?<br>https ://w zhihu . com/ question/ 54919485<br><a href="https://ww" target="_blank" rel="noopener">https://ww</a>. zhihu . com/ explore<br><a href="https://ww" target="_blank" rel="noopener">https://ww</a>. zhihu. com/ topic<br><a href="https://ww" target="_blank" rel="noopener">https://ww</a>. zhi hu . com/ topi c/ 19681388<br><a href="https://ww" target="_blank" rel="noopener">https://ww</a>. zhi hu . com/ topi c/19687351<br>ht tps://aw. zhi hu. com/ t.opi c/ 19630716<br>https ://ww . zhi hu . com/ topic/19637932<br><a href="https://w" target="_blank" rel="noopener">https://w</a>. zhi hu. com/ pecp1 e/weikexin一67<br><a href="https://w，zhi" target="_blank" rel="noopener">https://w，zhi</a> hu. com/ que sti 0n/267339149/answer/325252706<br><a href="https://w" target="_blank" rel="noopener">https://w</a>. zhihu . com/question/ 267339149/ answer/5233/1968<br><a href="https://ww" target="_blank" rel="noopener">https://ww</a>. zhi hu. com people/ zhang一jia hoo一 15<br>https :/www zhihu . com question/48510028<br>https :// AWw zhi hu. com/ question/ 267339149/ answer/ 323414411<br>https //ww zhihu. com pepple/ming ming 0701<br>https :/ww zhihu . com/ que stion/ 267 339149/answer/519709724<br>https :// AWw zhihu . com/ question/ 22897152<br>https //ww zhihu. com/question/22130215<br>htps://ww. zhihu . com/question/ 19823813 </p><p>什么是Vim宏(macro)<br>很多使用Vim很久的Vimer都没用过宏<br>◆宏可以看成是一系列命令的集合<br>◆我们可以使用宏[录制」一系列操作,然后用于「回放J<br>◆宏可以非常方便地把一系列命令用在多行文本上</p><p>如何使用宏<br>宏的使用分为录制和回放,是不是有种拍电影的感觉<br>◆Vim使用q来录制,同时也是q结束录制.<br>◆使用q{register}选择要保存的寄存器,把录制的命令保存其中. qa   I” esc A” esc q<br>◆使用@{register}回放寄存器中保存的一系列命令.  V  G   命令行模式回放宏命令   :normal @a<br>qa   I” esc A” esc q                                     V  G  :normal I”     :ctrl p    A”<br>V  G   命令行模式回放宏命令   :normal @a<br>用宏解决刚才的问题<br>现在你知道宏怎么用了,如何解决刚才的问题呢?<br>◆先给一行加上双引号,然后再回放到其他所有行<br>◆我们先使用q开始录制,给一行加上双引号,之后使用q退出<br>◆在剩下的所有行中回放录制的宏</p><p>课后练习<br>知道什么是宏,如何使用宏完成日常需求<br>◆想一下你编辑代码或文本的时候什么时候会使用到宏?<br>◆想一下我们还有没有其他方式来完成这个批量加弓|号的编辑需求<br>◆尝试亲自操作一下本章的示例,光听不练可学不会Vim </p><p>什么是补全?<br>只要手速快,补全什么的都是浮云<br>◆补全是根据当前环境上下文由编辑器猜你想输入的东西<br>◆比如补全一个单词、文件名,或者代码中的函数名、变量名等<br>◆Vim中提供了多种补全功能,还可以由插件拓展功能实现代码补全</p><p>Vim中常见的补全<br>Vim中有很多种补全的方式<br>命令<br>补全类型<br>&lt;C一n&gt;<br>普通关键字<br>&lt;C一x&gt;&lt;C一n&gt;<br>当前缓冲区关键字<br>&lt;C一X&gt;&lt;C一i&gt;<br>包含文件关键字<br>&lt;C一x&gt;&lt;C一]&gt;<br>标签文件关键字<br>&lt;C一x&gt;&lt;C一k&gt;<br>字典查找<br>&lt;C一x&gt;&lt;C一1&gt;<br>整行补全<br>&lt;C一x&gt;&lt;C一 f&gt;<br>文件名补全<br>&lt;C一x&gt;&lt;C一0&gt;， 全能(0mni)补全<br>:filetype on<br>:set filetype<br>常见的三种补全类型<br>记不住不用担心,根据笔者经验,最常用的就三种<br>◆使用ctrl+n和ctrl+p补全单词<br>◆使用ctrl+x ctrl+f补全文件名.  文件路径补全<br>◆使用ctrl+x ctrl+o补全代码,需要开启文件类型检查 ,安装插件</p><p>课后练习<br>知道如何在Vim中使用补全,补全的几种常见类型<br>◆尝试使用 Vim中的补全方式来补全单词<br>◆在Vim中输入文件名的时候尝试补全,想想如何输入现有文件名?<br>◆延伸:目前补全都是基于文本匹配的,插件可以实现代码补全</p><p>Vim更换配色<br>很多现代化的编辑器和IDE都支持更换主题, Vim当然也可以<br>◆使用:colorscheme显示当前的主题配色,默认是default<br>◆用:colorscheme &lt;ctrl+d&gt; 可以显示所有的配色<br>◆有中意的配色后,用:colorscheme配色名  就可以修改配色<br>Vim a.py b.txt -o</p><p>从网上下载配色<br>默认的配色没有喜欢的怎么办?<br>◆从网络上寻找更好看的配色<br>◆<a href="https://github.com/flazz/vim一colorschemes" target="_blank" rel="noopener">https://github.com/flazz/vim一colorschemes</a><br>◆安装之后就有大量的主题可以更换了</p><p>课后练习<br>看着喜欢的配色,敲代码才更舒服<br>◆尝试更改你的 Vim配色方案,想要持久化配置需要写到vimrc中<br>◆在网 上选找一一个你喜欢的配色方案,下载并且使用它,比如hybrid<br>◆你可以下载多个配色到.vim/colors并且随时更换</p><p>裸的Vim也很强<br>学Vim之前,先用对打字指法和盲打<br>◆编辑代码,脑子一般比手快,盲打有利于跟上你的大脑速度<br>◆裸的 Vim也有很多强大功能和使用方式<br>◆学会了用Vim ,你可以在你的IDE.上安装Vim插件,几乎所有流行的编辑器和IDE工具都支持Vim插件</p><p>如何编写Vim配置文件<br>如何编写自己的Vim配置文件呢?<br>◆Linux/Unix 下新建一个隐藏文件 vim ~/.vimrc.  ~表当前用户主目录  .表隐藏文件<br>◆windows系统vim $MYVIMRC ,通过环境变量编辑配置文件<br>◆接着我们就可以开始自定义自己的配置了</p><p>Vim配置都包含什么?<br>可以开始编辑vim配置文件了,但是需要设置什么呢?<br>◆常用设置,比如:set nu设置行号, colorscheme hybrid设置主题<br>◆常用的vim映射,比如noremap <leader>w :w<cr>保存文件<br>◆自定义的vimscript函数(vim高手)和插件的配置(插件篇会讲)</cr></leader></p><p>常用设置<br>首先是常用的Vim设置<br>◆&gt;我们可以把常用的设置写到.vimrc里避免每次打开vim重新设置<br>◆比如设置行号set nu;设置主题colorscheme hybird<br>◆Vim里有非常多这种配置,你可能需要参考下别人的配置<br>vimrc文件使用单个的“作为注释<br>1”常用设置<br>设置行号<br>3 set number<br>4 colorscheme hybrid<br>5 “按F2进入粘贴模式<br>6 set pastetoggle=<f2><br>7”高亮搜索<br>8 set hlsearch<br>9” 设置折叠方式<br>10 set fol dmethod=indent<br>11<br>12” 一些方便的映射<br>13 Let mapleader= ‘，<br>14 Let g:mapleader= ‘ ,’<br>15<br>16” 使用j进入normal模式<br>17 inoremap jj <esc> ^<br>18 使用leader+w 直接保存<br>19 inoremap <leader>w <esc> :W<cr><br>20 noremap <leader>w :W<cr><br>21<br>22”切换buffer<br>23 nnoremap <silent> [b :bprevious<cr><br>24 nnoremap <silent> [n : bnext<cr><br>25 use ctrl+h/j/k/l switch window<br>VISUAL LINE </cr></silent></cr></silent></cr></leader></cr></esc></leader></esc></f2></p><p>Vim中的映射<br>Vim中的映射比较复杂，源于vim有多种模式<br>◆设置一下leader键let mapleader = “,” 常用的是逗号或空格<br>◆比如用inoremap <leader>w <esc> :w<cr>在插入模式保存inoremap表insert非递归映射<br>◆Vim中的映射概念稍微复杂,但是非常强大,我们下一章单独讲。<br>:source ~/.vimrc  文件生效    编辑vimrc文件时:h option-list  /‘number</cr></esc></leader></p><ol><li>imooc vim:1:zsh 一 “wangningning<br>1 set number<br>2 syntax on<br>4 let mapleader= ‘ ,’<br>5 inoremap <leader>w <esc> :W<cr><br>: source ~/ . vimrc<br>( imooc _vim)0:zsh一 1 : zsh*</cr></esc></leader></li></ol><p>23 nnoremap <silent> [b : bprevious<cr>24 nnoremap <silent> [n : bnext<cr><br>25 use ctrl+h/j/k/l switch window<br>26 noremap &lt;C一h&gt; &lt;C一w&gt;h<br>27 noremap &lt;C一j&gt; &lt;C一w&gt;j<br>28 noremap &lt;C一k&gt; &lt;C 一W&gt;k<br>29 noremap &lt;C一1&gt; &lt;C一w&gt;l<br>30<br>31”Sudo to write<br>32 cnoremap w!! w !sudo tee % &gt;/dev/null33 ”json格式化<br>com! FormatJSON %!python3 一m json. tool36<br>37 “插件设置，这里使用了vim一plug<br>38 call plug#begin( ‘~/ .vim/plugged’)<br>39<br>40 安装插件只需要把github 地址放到这里重启后执行LugInstall就好了<br>41 Plug mhinz/vim一startify’<br>42 Plug ‘ scrooloose/nerdtree ‘<br>43<br>44 call plug#end()</cr></silent></cr></silent></p><p>Vim脚本<br>Vim有自己的脚本语言Vimscript<br>◆Vim脚本对于Vim高级玩家来说可以实现强大的vim插件<br>◆初学者知道有这个概念就好, vim脚本是一种简单的脚本语言<br>◆可以通过vimscript实现更多vim的控制,开发自己的插件</p><p>本章练习<br>掌握Vim配置需要对Vim本身很熟悉,不是一朝一 夕的事情<br>◆尝试自己建立一个.vimrc文件,加入常见的设置选项看看效果<br>◆请你研究 下github.上vim一go教程vim一go一tutorial的vimrc文件<br>◆拿来主义，网_上和很多人开源了自己的配置(dotfiles)可以参考学习<br>通过把vimrc配置放到git版本备库管理可以同步到其他电脑或者服务器上</p><p>什么是Vim映射<br>Vim映射就是把一个操作映射到「另一个操作」<br>◆如果你不满现在的按键设置?比如vim本来的命令<br>◆&gt;或者你想映射一些方便的快捷键<br>◆按照你的意愿定制Vim。当我按下某些键时,放弃你默认的操作按我的想法去做」</p><dl><dt>基本映射<br>基本映射指的是normal模式下的映射,当然还有其他模式的映射<br>◆使用map就可以实现映射。比如:map - x然后按一就会删除字符◆ :map <space> viw告诉vim按下空格的时候选中整个单词<br>:map &lt;c一d&gt; dd可以使用ctrl+d执行dd删除一行.加入vimrc文件时不需再加:vim默认解释为命令模式</space></dt><dd>unmap -    取消映射</dd></dl><p>模式映射<br>Vim常用模式normal/visual/insert都可以定义映射<br>◆用nmap/vmap/imap定义映射只在normal/visual/insert分别有效<br>◆:vmap \ U把在visual模式下选中的文本大小(u/U转换大小写)<br>◆想想我们如何在insert模式下映射ctrl+d来删除一行?  :imap <c-d> <esc>ddi</esc></c-d></p><p>UJLITITULITCIIL<br>11<br>12”一些方便的映射<br>13 let g:mapLeader= ‘,’<br>14<br>15”使用jj进入normal模式<br>16 inoremap jj <esc> `^<br>17”使用Leader+w直接保存<br>18 inoremap <leader>w <esc> :W<cr><br>19 noremap <leader>w :W<cr><br>20<br>21 “ 切换buffer<br>22 nnoremap <silent> [b : bprevious<cr><br>23 nnoremap <silent> [n : bnext <cr><br>24 “ use ctrl+h/j/k/l switch window<br>25 noremap <c-h> &lt;C -w&gt;h</c-h></cr></silent></cr></silent></cr></leader></cr></esc></leader></esc></p><p>现有映射的问题?<br>当你按下\时, Vim会解释其为-。我们又映射了- Vim会继续解析为dd，即它会删除整行。(是不是有点类似于递归)<br>:nmap - dd<br>:nmap \ -</p><p>Let mapleader=‘,’    默认leader键/。inoremap jj <esc> <code>^</code>^回到插入模式上次编辑的地点:help `^<br>递归与非递归映射</esc></p><ul><li>map系列命令有递归的风险<br>◆如果你安装了一个插件,插件映射了同一个按键的不同行为, 有冲突就会有一个失效<br>◆想要保证插件映射没有 冲突会非常痛苦<br>◆解决方案就是使用非递归映射</li></ul><p>非递归映射<br>Vim提供了非递归映射,这些命令不会递归解释<br>◆使用<em>map对应的nnoremap/vnoremap/inoremap<br>◆何时使用递归映射(</em>map) ?何时使用非递归映射呢? (*nnoremap)<br>◆任何时候你都应该使用非递归映射,拯救自己和插件作者</p><p>课后练习<br>映射可以让Vim按照你想要的方式工C作<br>◆尝试在你的vimrc中定义一些映射,提升你的工作效率<br>◆参考下一些开源的vim配置,看看哪些映射可以拿来用<br>◆阅读免费网络小书《笨方法学Vimscript》中关于映射的章节,这是一本学习 vim脚本的非常简单易懂的小书</p><p>学习和使用配置<br>学习和使用Vim配置是Vim玩家进阶的必修之路<br>◆了解常见的配置选项<br>◆学习和使用Vim映射,用得不爽我就改<br>◆Vim进阶需要了解Vimscript。《笨方法学Vimscript》</p><p>下一步该学什么?<br>该学习强大的Vim插件了<br>◆Vim也在与时俱进,最近发布了Vim8,还有 Neovim<br>◆知道如何配置Vim之后,可以开始探索各种强大的Vim插件了◆这一章打好了基础，我们开始学习如何安装和使用插件</p><p>什么是插件?<br>和其他现代流行编辑器一样, Vim同样支持强大的插件扩展<br>◆Vim插件是使用vimscript或者其他语言编写的vim功能扩展<br>◆编辑器自带的功能有限,有了插件之后几乎可以无限制扩充其功能<br>◆网络上比如github.com等有很多开源的vim插件可以使用</p><p>如何安装插件?<br>原始的方式是直接clone插件代码,如今vim有很多插件管理器<br>◆目前Vim有很多插件管理器可供选择,你可以选择一个顺手的◆常见的有vim-plug, Vundle, Pathogen, Dein.Vim, volt等◆综合性能、易用性、文档等几个方面,这里推荐使用vim-plug</p><p>使用vim一plug安装插件<br>我们将使用vim一plug安装我们的第一个插件<br>◆<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug</a><br>◆学习一个新东西的最好方式就是看官方的文档示例<br>◆按照官方的教程,我们就可以非常容易地了解它的使用方式</p><p>14<br>15 com! FormatJSON %!python3 一m json. tool16<br>Specify a directory for plugins<br>18 For Neovim: ~/ . local/share/nvim/plugged<br>19 Avoid using standard Vim directory names like ‘ plugin’20 call plug#begin(‘ ~/ .vim/plugged’ )<br>21<br>22” Initialize plugin system<br>23 call plug#end()</p><p>安装你的第一个插件<br>我们将安装vim-startify , 一个好用的vim开屏插件◆<a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a><br>◆修改你的.vimrc文件,增加该插件名称<br>◆重新启动vim或者source 一下.vimrc ,执行:PlugInstall<br>:qa退出所有窗口<br>1.安装vim-plug插件管理器 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug</a><br>2.使用vim-plug 和vimrc安装插件 vim <del>/.vimrc<br>      call plug#begin(‘</del>/.vim/plugged’)<br>      Plug ‘mhinz/vim-startify’<br>      “ Initialize plugin system<br>      call plug#end()<br>3.重新启动vim或者source 一下.vimrc ,执行:PlugInstall</p><p>安装完成看效果<br>如果你已经安装完成,重新退出并且打开你的vim吧<br>◆重启你的Vim你见过会神奇地发现插件生效了!◆安装一个插件是不是非常简单呢<br>◆其他插件安装方式非常类似</p><p>课后练习<br>打开你的Vim操练起来吧，首先下载vim-plug并浏览其文档◆请在你的电脑上安装vim-plug这个方便的插件管理器<br>◆安装你的第一个vim插件vim-startify ,看看能否生效◆下一 章我们将介绍一下如何快速找到你需 要的插件</p><p>如何搜寻插件 startify   nerdtree  python-mode<br>现有需求,后有插件。大部分插件托管在了github上<br>◆通过google搜索关键词寻找想要的插件 vim file manager  plugin<br>◆<a href="https://vimawesome.com/" target="_blank" rel="noopener">https://vimawesome.com/</a><br>◆浏览网上开源的vim配置借鉴想要的插件</p><p>vim美化插件<br>更改vim的外观<br>◆修改启动界面: <a href="https://github.com/mhinz/vim一startify◆状态栏美化" target="_blank" rel="noopener">https://github.com/mhinz/vim一startify◆状态栏美化</a>: <a href="https://github.com/vim一airline/vim一airline" target="_blank" rel="noopener">https://github.com/vim一airline/vim一airline</a><br>◆增加代码缩进线条: <a href="https://github.com/yggdroot/indentline" target="_blank" rel="noopener">https://github.com/yggdroot/indentline</a></p><p>vim配色方案<br>找到一个你喜欢的配色<br>◆vim一hybird 配色: github.com/w0ng/vim-hybrid<br>◆solarized 配色: github.com/ altercation/vim一colors一solarized◆gruvbox 配色: github.com/morhetz/gruvbox</p><p>课后练习<br>请你尝试安装本章提到的三个插件,然后给自己的vim换个配色◆尝试使用vim一startify快速打开最近的使用的文件<br>◆安装vim一airline美化你的状态栏<br>◆安装indentline给vim增加代码缩进线</p><p>文件管理器nerdtree<br>使用nerdtree插件进行文件目录树管理<br>◆<a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a><br>◆ autocmd vimenter * NERDTree命令粘贴在vimrc可以在启动vim的时候打开◆nnoremap <leader>v :NERDTreeFind<cr>查找文件位置<br>映射,v跳转到文件在目录树中对应的位置,ctrl w p跳回文件中<br>快速搜索文件<br>如果想快速根据文件名查找打开一个文件呢?</cr></leader></p><p>模糊搜索器<br>如果想快速查找并且打开一个文件可以用ctrlp插件<br>◆<a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">https://github.com/ctrlpvim/ctrlp.vim</a><br>◆let g:ctrlp_map = ‘<c-p>‘<br>◆使用ctrl+ p然后开始输入少量字符就可以搜索啦</c-p></p><p>课后练习<br>快速定位一个文件是一个常用操作，要好好掌握提升效率◆请你安装nerdtree插件,加入自己的快捷键映射<br>◆安装ctrlp插件,然后尝试下快速定位文件<br>◆改变自己之前低效的操作方式,适应新的操作方式在项目的根目录下可高效操作文件</p><p>Vim移动命令<br>在基础篇我们讲了很多vim中移动的命令<br>◆比如w/e基于单词移动,gg/G文件首尾, 0/$行首位,f{char}查寻字符◆ctrl+f ctrl+u前后翻屏<br>◆那假如我想快速跳到当前窗口显示区的任意位置呢?</p><p>如何移动到任意位置<br>可以使用vim的搜索/加上n跳转,但是使用easymotion更方便◆<a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">https://github.com/easymotion/vim-easymotion</a><br>◆官方文档比较长,很多人没有看懂怎么用,实一个映射就能应付◆nmap ss <plug>(easymotion-s2)</plug></p><p>vim一surround<br>如果快速让你更换一对单引号为双引号,你会怎么做?◆一个一个查找然后替换,是不是比较低效?<br>◆<a href="https://github.com/tpope/vim-surround" target="_blank" rel="noopener">https://github.com/tpope/vim-surround</a></p><p>vim一surround使用<br>normal模式下增加,删除,修改成对内容◆ds (delete a surrounding)<br>◆CS (change a surrounding)<br>◆ys (you add a surrounding)</p><p>self . name = “name” # ys iw “</p><p>print(‘ gua gua’) # cs “ ‘</p><p>print[“man gua gua”] # cs ( ]</p><p>d = Duck( ‘ duck’) # ds ‘<br>课后练习<br>vim一surround大法好<br>◆请你使用vim一plug安装vim一surround插件<br>◆尝试练习使用它来修改成对的内容,比如修改单引号为双引号◆多练习几次,使用插件提升编辑效率,改掉以前的低效操作方式</p><p>模糊搜索<br>我们经常需要在一个代码项目中模糊搜索一些文本,怎么办呢?<br>◆Vim自带的搜索/可以搜索当前文件,但是项目有很多个文件<br>◆ 需要一个插件来模糊搜索多个文件内容<br>◆使用Ag.vim或者fzf.vim都可以很好地支持模糊搜索</p><p>fzf与fzf.vim. 可完全替代ctrlP插件<br>fzf是一个强大的命令行模糊搜索工具, fzf.vim集成到了vim里◆<a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim</a><br>◆使用Ag [PATTERN]模糊搜索字符串 Ag duck  map<br>◆使用Files [PATH]模糊搜索目录Files .</p><p>搜索替换插件far.vim   打开多个文件<br>如果想要批量搜索替换,可以试试far.vim     e ~/.vimrc 在不退出vim情况下编辑vmrc<br>◆<a href="https://github.com/brooth/far.vim" target="_blank" rel="noopener">https://github.com/brooth/far.vim</a><br>◆比如在重构代码的时候经常会用到<br>◆:Far foo bar <em>*/</em>.py       Fardo指定替换的文件,上层目录当前目录*表示所有的文件类型</p><p>课后练习<br>模糊搜索和替换是一个非常常用的操作<br>◆请你使用vim一plug安装fzf.vim和far.vim<br>◆尝试使用fzf.vim在一个项目中搜索你想要的文本◆使用far.vim批量替换一个项目下的文本</p><p>愉快写golang之vim一go插件</p><p>编辑器VS IDE<br>IDE一代又一代,经典的编辑器却长久不衰<br>◆除了Java ,很多人用vim编写shell/php/golang/python/ruby◆前端很多人使用vscode，sublime/Atom 有末落之势<br>◆很多后端和运维工程师使用vim ,微信后台和阿里”飞天系统很多代码出自在服务器上使用vim的工程师</p><p>vim一go<br>功能强大的golang插件vim一go<br>◆<a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a><br>◆代码补全,重构,跳转,自动格式化，自动导入等功能◆基本可以满足golang日常开发<br>Go 默认使用的tab缩进.全能补全ctrl x o 触发。ctrl ]跳至定义处vim里面 ctrl o跳回ctrl i往前跳<br>:GoFmt  代码格式化。 :GoRename  代码重构。:GoImports自动导入  :GoRun运行<br>课后练习<br>安装vim一go插件<br>◆请你安装vim一go插件,阅读vim一go一tutorial教程<br>◆尝试开始使用vim一go插件编写go语言代码<br>◆如果遇到了问题,请你查看vim一go一tutorial教程或者vim一go文档</p><p>Python一mode<br>Python插件使用比较多的是jedi一vim和python一mode<br>◆<a href="https://github.com/python-mode/python-mode" target="_blank" rel="noopener">https://github.com/python-mode/python-mode</a><br>◆python一mode同样具备基本的补全、跳转、重构、格式化功能◆即使是在服务器上也能愉快调试python代码了</p><p>课后练习<br>安装python一mode插件<br>◆&gt;请你安装python一mode插件<br>◆开始使用python一mode编写Python 代码<br>◆如果遇到了问题,尝试查询python一mode文档解决</p><p>tagbar<br>代码大纲, Vim当然也有,而且支持非常多编程语言◆<a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a><br>◆需要安装Universal Ctags生成对应的tag文件<br>◆快速浏览当前文件代码结构,并且搜索跳转到对应代码块 :TagbarToggle</p><p>vim一interestingwords<br>高亮你感兴趣的单词，浏览代码很有用<br>◆<a href="https://github.com/lfv89/vim-interestingwords◆&gt;浏览代码的时候经常需要知道一个变量的使用方式◆我们可以使用这个插件同事高亮多个单词Highlight" target="_blank" rel="noopener">https://github.com/lfv89/vim-interestingwords◆&gt;浏览代码的时候经常需要知道一个变量的使用方式◆我们可以使用这个插件同事高亮多个单词Highlight</a> with <leader>kNavigate highlighted words with n and NClear every word highlight with <leader>K throughout the buffer</leader></leader></p><p>课后练习<br>安装tagbar和interestingwords<br>◆安装tagbar ,开启你的代码大纲吧<br>◆安装interestingwords高亮你感兴趣的单词.<br>◆如果遇到了问题,尝试查询插件的官方文档/google/vim help解决</p><p>deoplete.nvim<br>一个强大的neovim/vim8异步补全插件<br>◆<a href="https://github.com/shougo/deoplete.nvim◆多编程语言的支持,支持模糊匹配" target="_blank" rel="noopener">https://github.com/shougo/deoplete.nvim◆多编程语言的支持,支持模糊匹配</a><br>◆需要安装对应编程语言的扩展</p><p>coc.vim<br>一个强大的neovim/vim8补全插件。LSP 支持<br>◆<a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">https://github.com/neoclide/coc.nvim</a><br>◆full Language Server Protocol support as VSCode◆多语言插件支持</p><p>课后练习<br>尝试安装和使用deoplete.nvim<br>◆安装 deoplete.nvim或者coc.nvim<br>◆安装对应的编程语言扩展<br>◆vim/neovim补全插件有很多,有些支持异步, 找到最适合你的</p><p>格式化与静态检查<br>为什么需要这些工具呢?能让工具做的就不用让人去费心<br>◆&gt;把精力集中代码逻辑本身,而不是整理格式这些浪费精力的事情上◆静态检查是为了让编写的代码更加规范。golint/pylint/eslint等◆无论你编写何种编程语言,最好都加上自动格式化和静态检查</p><p>Neoformat<br>vim一autoformat和Neoformat是两种使用较多的格式化插件◆你可以按照自己的喜好来选择,这里我们使用neoformat<br>◆<a href="https://github.com/sbdchd/neoformat" target="_blank" rel="noopener">https://github.com/sbdchd/neoformat</a><br>◆需要安装对应语言的格式化库。 python autopep8/js的prettier等</p><p>静态检查Lint<br>neomake和ale是两种常用的lint插件,这里我们选用ale◆<a href="https://github.com/w0rp/ale" target="_blank" rel="noopener">https://github.com/w0rp/ale</a><br>◆同样需要安装对应语言的lint库。比如eslint/pylint/golint等◆vim8/neovim 支持异步检查,不会影响vim编辑,推荐使用</p><p>课后练习<br>让插件帮你完成代码的格式化和静态检查吧,解放你的生产力<br>◆安装neoformat插件和相关的格式化库,格式化你的代码◆安装ale和对应语言的lint库,修复你代码的缺陷<br>◆需要自定义检查功能 (比如忽略某些检查错误)请参考官方文档</p><p>vim一commentary<br>vim注释插件有很多,这里使用这个比较轻量的<br>◆<a href="https://github.com/tpope/vim-commentary" target="_blank" rel="noopener">https://github.com/tpope/vim-commentary</a><br>◆记住常用的命令gc注释和取消注释<br>◆插件会根据不同的文件类型使用不同注释, python(#) golang(//)</p><p>课后练习<br>安装vim一commentary<br>◆安装vim一commentary插件<br>◆尝试打开一个python文件快速注释一段代码<br>◆打开不同类型文件，比如go文件试试注释一段代码或者文字</p><p>Fugitive<br>在Vim里使用Git<br>◆<a href="https://github.com/tpope/vim-fugitive" target="_blank" rel="noopener">https://github.com/tpope/vim-fugitive</a><br>◆Gedit, Gdif, Gblame, Gcommit等<br>◆笔者更喜欢用tmux新开一个窗口来使用git ,后面我们会讲到</p><p>vim一gitgutter<br>在vim里显示文件变动<br>◆<a href="https://github.com/airblade/vim-gitgutter◆当我们修改文件之后可以显示当前文件的变动◆哪些行新增,哪些行修改了,哪些行删除了" target="_blank" rel="noopener">https://github.com/airblade/vim-gitgutter◆当我们修改文件之后可以显示当前文件的变动◆哪些行新增,哪些行修改了,哪些行删除了</a></p><p>gv.vim<br>如何在命令行查看提交记录呢?有个命令行工具叫做tig◆<a href="https://github.com/junegunn/gv.vim" target="_blank" rel="noopener">https://github.com/junegunn/gv.vim</a><br>◆使用:GV命令调用<br>◆可以浏览代码提交变更</p><p>课后练习<br>安装这三个git插件<br>◆尝试安装这几个git插件<br>◆使用下Gblame等命令<br>◆后面我们会讲vim和tmux配合使用</p><p>Vim插件千3万<br>本章我们介绍了如何安装和使用常见的插件<br>◆Vim插件很多,不可能都全部介绍。学会自己寻找和安装<br>◆通过搜索引擎google关键词/vimawesome/参考 开源配置寻找插件◆学会阅读插件的 Readme文件和doc里的帮助文件学习插件使用</p><p>1「mux<br>强大的终端复用工具。通过brew(mac) apt一get(ubuntu)安装◆可以复用终端、分屏、托管进程等<br>◆在服务器上即使退出服务器也不会被kill ,托管进程也很方便◆可以方便地分割屏幕实现多个进程公用屏幕</p><p>T ‘mux<br>强大的终端复用工具。通过brew(mac) apt一get(ubuntu)安装◆可以复用终端、分屏、托管进程等<br>◆在服务器上即使退出服务器也不会被kill ,托管进程也很方便◆可以方便地分割屏幕实现多个进程公用屏幕</p><p>课后练习<br>在你的系统或者服务器.上安装tmux<br>◆使用tmux尝试分隔屏幕<br>◆尝试一个窗口编写代码, 一个窗口使用shell命令◆尝试退出和重新attach到一个tmux的会话</p><p>几乎流行的编辑器和IDE都支持vim插件让vim嵌入你的开发工具,甚至chrome都有vimium插件<br>◆即使你不用vim作为主力编辑器,依然可以使用它的编辑方式◆几乎流行的开发工具都支持vim插件,以vim的方式编辑.◆比如Vscode/Atom/Pycharm等都支持安装vim插件</p><p>课后练习<br>如果你使用的不是vim ,请寻找对应的vim插件安装◆搜索你的开发工具的vim插件<br>◆安装vim插件到你的开发工具里<br>◆尝试在各种开发工 具中使用vim的方式编辑提升效率</p><p>Neovim<br>一个新的vim版本支持异步特性( vim8也支持)<br>◆<a href="https://neovim.io/" target="_blank" rel="noopener">https://neovim.io/</a><br>◆开发更活跃,更丰富的特性和扩展,异步支持<br>◆neovim的设计可以嵌入到很多GUI里,加上好看的「外壳J</p><p>开箱即用<br>如果你已经熟悉了vim配置,可以从网上直接使用一些开源配置◆<a href="https://github.com/SpaceVim/SpaceVim" target="_blank" rel="noopener">https://github.com/SpaceVim/SpaceVim</a><br>◆<a href="https://github.com/PegasusWang/vim一config" target="_blank" rel="noopener">https://github.com/PegasusWang/vim一config</a><br>◆其他开源配置。不推荐新手直接使用,越复杂的配置上手成本越高</p><p>课后练习<br>找到一个你喜欢的开源配置<br>◆找到一个你喜欢的开源配置,尝试安装它<br>◆阅读其文档，了解使用方式。一般开源配置都安装了很多插件◆对于新手来说,配置太复杂太强大有时候可能会出现很多小问题</p><p>学习万法<br>熟练vim靠的是肌肉记忆。脱离鼠标编辑能提升编辑效率<br>◆虽然讲了这么多, vim仍然很多东西没有讲,时不时发现一些技巧◆在学中练,在练中学。熟能生巧,肌肉记忆<br>◆衡量投入产出比,是点到为止还是继续深入</p><p>继续练级<br>网络.上很多vim的资源,甚至练习的小游戏◆《Practical vim》<br>◆《举方法学 vimscript》<br>◆学习和开发自己的插件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Visual(可视)模式&lt;br&gt;Visual模式一般用来块状选择文本&lt;br&gt;Normal模式下使用v进入visual选择&lt;br&gt;使用V选择行◆使用ctrl+v进行方块选择&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>小笔记-小心得</title>
    <link href="http://yoursite.com/2020/01/16/%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%B0%8F%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2020/01/16/%E5%B0%8F%E7%AC%94%E8%AE%B0-%E5%B0%8F%E5%BF%83%E5%BE%97/</id>
    <published>2020-01-15T23:39:55.000Z</published>
    <updated>2020-02-28T12:51:49.655Z</updated>
    
    <content type="html"><![CDATA[<p>躬身入局<br>法国作家 加缪:<br>请不要跟在我后面,因为我可能不会引路;也不要走在我的前面因为我可能不会跟随;请走在我的旁边做我的朋友.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;躬身入局&lt;br&gt;法国作家 加缪:&lt;br&gt;请不要跟在我后面,因为我可能不会引路;也不要走在我的前面因为我可能不会跟随;请走在我的旁边做我的朋友.&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Blog-搭建</title>
    <link href="http://yoursite.com/2019/12/30/Hexo-Blog-%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/12/30/Hexo-Blog-%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-30T15:39:53.000Z</published>
    <updated>2020-02-28T12:26:55.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.2.jpg" alt="Hexo"></p><p>  很久之前学习的这个博客框架搭建了,现在拿来用都已经忘光了.大概总结一下免得到时候忘记又得在网上找资料重新来过.</p><h2 id="一-安装环境准备"><a href="#一-安装环境准备" class="headerlink" title="一.安装环境准备:"></a>一.安装环境准备:</h2><pre><code>下载安装node.jsiterm:sudo su切换到root用户   安装hexo 博客框架  Npm install -g cnpm --registry=https://registry.npm.taobao.orgCnpm install -g hexo-cliHexo -vPwdMkdir  blogCd blog/PwdSudo hexo initHexo start/server. Blog 预览</code></pre><a id="more"></a><h2 id="二-新建文章"><a href="#二-新建文章" class="headerlink" title="二.新建文章"></a>二.新建文章</h2><pre><code>Hexo new“我的第一篇博客文章”cd到相应目录下 vim 文章基于markdown格式语法写文章---##第一章内容---##第二章内容---## 参考文献:wqCd ../..Hexo cleanHexo gHexo s</code></pre><h2 id="三-部署到github上"><a href="#三-部署到github上" class="headerlink" title="三.部署到github上"></a>三.部署到github上</h2><pre><code>登录GitHub new repository :昵称.github.ioCreateIterm:目录下安装git部署插件-npm install --save hexo-deployer-gitll设置Vim  -config.yml#deploymentDeploy: type:gitRepo:Branch: masterHexo dhttps://alexyangz.github.io/更换主题:blog目录下下载主题Git clone   url1.   themes/yille配置-config.yml![lovely](/images/1.11.jpg)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/1.2.jpg&quot; alt=&quot;Hexo&quot;&gt;&lt;/p&gt;

&lt;p&gt;  很久之前学习的这个博客框架搭建了,现在拿来用都已经忘光了.大概总结一下免得到时候忘记又得在网上找资料重新来过.&lt;/p&gt;
&lt;h2 id=&quot;一-安装环境准备&quot;&gt;&lt;a href=&quot;#一-安装环境准备&quot; class=&quot;headerlink&quot; title=&quot;一.安装环境准备:&quot;&gt;&lt;/a&gt;一.安装环境准备:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;下载安装node.js
iterm:sudo su切换到root用户
   安装hexo 博客框架
  Npm install -g cnpm --registry=https://registry.npm.taobao.org
Cnpm install -g hexo-cli
Hexo -v
Pwd
Mkdir  blog
Cd blog/
Pwd
Sudo hexo init
Hexo start/server. Blog 预览&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="生产力" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
</feed>
